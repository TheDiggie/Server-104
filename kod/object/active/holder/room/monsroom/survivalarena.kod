// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
SurvivalArena is MonsterRoom

constants:

   include blakston.khd

   TROPHY_WAVES = 1
   TROPHY_KILLS = 2
   TROPHY_KILLS2 = 3

   SECTOR_ID_FIGHT = 2
   SECTOR_ID_BARS = 3

   // Includes the bar surrouding part
   SECTOR_ID_BEHIND_BARS = 4
   SECTOR_ID_GREEN = 5

   SECTOR_ID_WATER_INPLAY = 11
   SECTOR_ID_BEHIND_BARS_WATER = 14

   SECTOR_ID_PILLAR_A = 20
   SECTOR_ID_PILLAR_B = 21
   SECTOR_ID_PILLAR_C = 22
   SECTOR_ID_PILLAR_D = 23

   SECTOR_ID_STAIRS_A = 30
   SECTOR_ID_STAIRS_B = 31
   SECTOR_ID_STAIRS_C = 32
   SECTOR_ID_STAIRS_D = 33
   SECTOR_ID_STAIRS_E = 34
   SECTOR_ID_STAIRS_F = 35

   GROUND_HEIGHT = 252
   PILLAR_A_HEIGHT = 312
   PILLAR_BC_HEIGHT = 320
   PILLAR_D_HEIGHT = 304

   STAIRS_A_HEIGHT = 264
   STAIRS_B_HEIGHT = 272
   STAIRS_C_HEIGHT = 280
   STAIRS_D_HEIGHT = 288
   STAIRS_E_HEIGHT = 296
   STAIRS_F_HEIGHT = 304

   // Percent of monsters that will aggro
   AGGRO_CHANCE = 20
   // Max number of monsters that will aggro per call
   AGGRO_MAX = 5

resources:

   include survivalarena.lkod

   room_SurvivalArena = survival_ex.roo
   room_name_SurvivalArena = "The Hallowed Training Grounds"
   SurvivalArena_music = dance1.ogg

   SurvivalArena_no_offer = \
      "Osvann Vaendefdall says, \"Spectators and combatants may not exchange goods "
      "during matches."
   SurvivalArena_cant_go = \
      "Osvann Vaendefdall says, \"You can't leave!  You're a combatant!\""

   SurvivalArena_sign_name = "Using the Training Grounds"
   SurvivalArena_sign_text = \
      "Say the name of the game you wish to play.\n\n"
      "SURVIVAL:\nSay 'join' or 'leave' to enter or leave the arena.\n"
      "Combatants will need to kill all the enemies in order to progress to "
      "the next wave of creatures. The difficulty increases as the players "
      "advance through each level.\n\n"
      "CLASSIC SURVIVAL: Say commands below:\n"
      "Say 'start solo survival'\n"
      "Say 'start public survival'\n"
      "Say 'join public survival'\n"
      "Say 'start guild survival'\n"
      "Say 'join guild survival'\n\n"
      "TRADITIONAL: Traditional bouts are those between only two combatants.\n\n"
      "LAST MAN STANDING: Every man for himself.\n\n"
      "GUILD VS GUILD: Two guilds may choose to combat each other.\n\n"
      "BATTLE ROYALE: A mix between last man standing and guild vs guild."

   SurvivalArena_locked_house = \
      "The door to Osvann Vaendefdall's house is locked."

   SurvivalArena_start_tournament = \
      "Banners unfurl and bugles warble to signify the beginning of the "
      "Royal Tournament!"
   SurvivalArena_end_tournament = "The Royal Tournament has come to an end."

   SurvivalArena_Fanfare_Sound = fanfare1.ogg
   SurvivalArena_Combat_Sound = arena1.ogg
   SurvivalArena_Huzzah_Sound = huzzah.ogg
   SurvivalArena_gong_sound = gong.ogg

classvars:

   vrName = room_name_SurvivalArena
   viTeleport_row = 47
   viTeleport_col = 31

   viPermanent_flags = ROOM_SAFE_DEATH
   viWeatherZone = WEATHER_ZONE_BERG
   vbScaleSpawnRateWithPlayers = FALSE
   vbAccessibleForFollowers = FALSE

   vbIsExpansionRoom = TRUE

properties:

   prRoom = room_SurvivalArena
   piRoom_num = RID_SURVIVAL_ARENA
   prMusic = SurvivalArena_music

   piBaseLight = LIGHT_NICE
   piOutside_factor = 8
   piDirectional_percent = DIRECTIONAL_PERCENT_OUTDOORS
   viTerrain_type = TERRAIN_CITY
   pbSnowGroundTexture = TRUE
   
   pbGenerateMonsters = FALSE
   pbRespawnMonsters = FALSE
   piReload_Wait_Time = 1
   piGen_time = 1000
   piGen_percent = 100
   piInit_count_min = 10
   piInit_count_max = 10
   piMonster_count_max = 30
   piMonster_adjusted_max = $

   // Needed to correctly apply snow texture to certain linedefs.
   pbIsMazeBDown = FALSE
   pbIsMazeCDown = FALSE

   pbRealdeath = FALSE
   pbNoReagents = FALSE

   plBosses = $
   plMiniBosses = $
   poWatcher = $

messages:

#region Create and Delete
   Constructed()
   {
      plGenerators = [ [46, 19], [46, 21], [47, 20], [48, 19], [48, 21],
                       [12, 57], [14, 57], [13, 58], [12, 59], [14, 59] ];

      plMiniBosses = [
                      &SpiderQueen,
                      &GroundWormQueen,
                      &MolluskMonster,
                      &Thrasher,
                      &Shadowbeast,
                      &DragonFlyQueen,
                      &AvarChieftain,
                      &GiantRatKing,
                      &EarthElemental,
                      &FireElemental,
                      &IceElemental,
                      &NeruElemental,
                      &Minotaur];
                      
      plBosses =     [&EarthElementalChampion,
                     &FireElementalChampion,
                     &IceElementalChampion,
                     &NeruElementalChampion,
                     &Yeti,
                     &LupoggKing,
                     &GiantDaemonSkeleton];

      Send(self,@RecalcLightAndWeather);
      Post(self,@SetRoomFlag,#flag=ROOM_NO_PK,#value=TRUE);

      propagate;
   }

   CreateStandardObjects()
   {
      local lObjCoords1, oSign, oObj;

      if poWatcher = $
      {
         poWatcher = Create(&SurvivalWatcher);
         Send(self,@NewHold,#what=poWatcher,
                #new_row=43,#new_col=43,#fine_row=0,#fine_col=0);

         Send(self,@NewHold,#what=Create(&Sign,#newbie=TRUE,
            #desc=SurvivalArena_sign_text,#name=SurvivalArena_sign_name),
            #new_row=44,#new_col=43,#fine_row=24,#fine_col=0);
      }
      
      lObjCoords1 = [ [52,36, OO_SHRUBEE1], [52,40, OO_SHRUBEE1],
                      [52,47, OO_SHRUBEE1], [52,51, OO_SHRUBEE1],
                      [27, 7, OO_SHRUBEE1], [32, 7, OO_SHRUBEE1],
                      [29,21, OO_MIDTREE2], [23,23, OO_MIDTREE2],
                      [21,47, OO_MIDTREE2], [40,31, OO_MIDTREE2],
                      [40,50, OO_MIDTREE2], [31,59, OO_MIDTREE2],
                      [27,57, OO_MIDTREE2], [47,32, OO_MIDTREE1],
                      [47,51, OO_MIDTREE1], [51,61, OO_MIDTREE1],
                      [42,69, OO_MIDTREE1], [52,28, OO_MIDTREE1],
                      [46,12, OO_MIDTREE1], [35,11, OO_MIDTREE1],
                      [21,11, OO_MIDTREE1], [26,70, OO_MIDTREE1],
                      [11,70, OO_MIDTREE1], [12,13, OO_MIDTREE1],
                      [13,24, OO_MIDTREE1], [12,47, OO_MIDTREE1],
                      [ 4,57, OO_MIDTREE1]
                    ];
      Send(self,@CreateOrnObjFromList,#lObjlist=lObjCoords1);

      // Lightning
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=52,#new_col=31,#fine_row=0,#fine_col=32);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=50,#new_col=37,#fine_row=40,#fine_col=40);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=51,#new_col=40,#fine_row=24,#fine_col=32);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=51,#new_col=45,#fine_row=24,#fine_col=40);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=50,#new_col=49,#fine_row=40,#fine_col=16);

      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=52,#new_col=55,#fine_row=40,#fine_col=56);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=32,#new_col=8,#fine_row=48,#fine_col=32);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=30,#new_col=8,#fine_row=32,#fine_col=24);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=28,#new_col=8,#fine_row=0,#fine_col=24);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=35),
         #new_row=25,#new_col=8,#fine_row=44,#fine_col=44);

      propagate;
   }

   CreateStandardExits()
   {
      plExits = $;
      plExits = Cons([ 13, 68, ROOM_LOCKED_DOOR, SurvivalArena_locked_house ],plExits);
      plExits = Cons([ 14, 68, ROOM_LOCKED_DOOR, SurvivalArena_locked_house ],plExits);

      plEdge_Exits = $;

      plEdge_Exits = Cons([ LEAVE_SOUTH, RID_BERG_8, 2, 60, ROTATE_NONE ], plEdge_exits);
      plEdge_Exits = Cons([ LEAVE_WEST, RID_J3_2, 3, 39, ROTATE_NONE ], plEdge_exits);

      propagate;
   }
#endregion Create and Delete

   CanOffer(who = $, target = $)
   {
      if who = $ or target = $
      {
         return FALSE;
      }

      if (poWatcher = $
         OR NOT Send(poWatcher,@FightInSession)
         OR (Send(poWatcher,@IsCombatant,#who=who)
            = Send(poWatcher,@IsCombatant,#who=target)))
      {
         return TRUE;
      }

      Send(who,@MsgSendUser,#message_rsc=SurvivalArena_no_offer);

      return FALSE;
   }

   CheckWatcher(what=$)
   {
      if poWatcher = $
      {
         poWatcher = what;
         Send(self,@NewHold,#what=what,#new_row=43,#new_col=43,
               #fine_row=0,#fine_col=0);
      }

      return;
   }

   SafePlayerAttack()
   {
      return TRUE;
   }

   NewHoldObject(what=$)
   {
      local oOwner, oTarget, iRow, iCol;
      
      if IsClass(what,&User)
      {
         oOwner = Send(what,@GetOwner);
         if (oOwner = $
            AND NOT Send(poWatcher,@IsCombatant,#who=what))
         {
            Post(self,@Teleport,#what=what,#outofplay=TRUE);
         }
      }

      propagate;
   }

   InPlay(what=$, bNonPlayerOkay = FALSE)
   "Returns true if player is on playing field, false if not."
   "Can check either by row and column or by object."
   "Returns false if not a player, unless the nonPlayerOkay flag is marked"
   {
      local iSectorID;

      if what = $
      {
         return FALSE;
      }

      if IsClass(what,&Player) OR bNonPlayerOkay
      {
         iSectorID = Send(what,@GetSectorIDAtObject);

         return iSectorID = SECTOR_ID_FIGHT
                OR iSectorID = SECTOR_ID_WATER_INPLAY
                OR iSectorID = SECTOR_ID_BARS
                OR iSectorID = SECTOR_ID_BEHIND_BARS
                OR iSectorID = SECTOR_ID_BEHIND_BARS_WATER
                OR iSectorID = SECTOR_ID_GREEN
                OR iSectorID >= SECTOR_ID_PILLAR_A; // >= 20
      }

      return FALSE;
   }

   IsArena()
   {
      return TRUE;
   }

   GetWatcher()
   {
      return poWatcher;
   }

   Teleport(what=$,goinplay=FALSE,outofplay=FALSE)
   {
      local i;

      // Don't teleport players if logged off.
      if (what = $
         OR (IsClass(what,&User)
            AND NOT Send(what,@IsLoggedOn)))
      {
         return;
      }

      // Check goinplay and outofplay first. If we don't have
      // a parameter set, teleport combatants in and anyone else out.
      if goinplay
      {
         Send(self,@TeleportIntoPlay,#who=what);
      }
      else if outofplay
      {
         Send(self,@TeleportOutOfPlay,#who=what);
      }
      else if Send(poWatcher,@IsCombatant,#who=what)
      {
         Send(self,@TeleportIntoPlay,#who=what);
      }
      else
      {
         Send(self,@TeleportOutOfPlay,#who=what);
      }

      return;
   }

   TeleportIntoPlay(who=$)
   {
      local i, iRow, iCol;

      // Teleport to the playing field
      iRow = Random(23,38);
      iCol = Random(35,45);
      Send(SYS,@UtilGoNearSquare,#what=who,#where=self,
            #new_row=iRow,#new_col=iCol,#mob_override=TRUE);

      // Teleport minions too.
      foreach i in Send(who,@GetControlledMinions)
      {
         if (Send(i,@GetOwner) = self)
         {
            Send(self,@TeleportIntoPlay,#who=i);
         }
      }

      return;
   }

   TeleportOutOfPlay(who=$, iNum=0)
   {
      local i, iRow, iCol, iAngle;

      if (iNum = 0)
      {
         iNum = Random(1,2);
      }

      if iNum = 1
      {
         iRow = 30;
         iCol = 27;
         iAngle = ANGLE_SOUTH;
      }
      else
      {
         iRow = 30;
         iCol = 51;
         iAngle = ANGLE_NORTH;
      }

      Send(SYS,@UtilGoNearSquare,#what=who,#where=self,#new_row=iRow,
            #new_col=iCol,#new_angle=iAngle,#mob_override=TRUE);

      // Teleport minions too.
      foreach i in Send(who,@GetControlledMinions)
      {
         if (Send(i,@GetOwner) = self)
         {
            Send(self,@TeleportOutOfPlay,#who=i,#iNum=iNum);
         }
      }

      return;
   }

   SpecialGreeting()
   {
      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_Fanfare_Sound);

      return;
   }

   ArenaEndFight(lCombatants = $)
   {
      local i, j, k;

      Send(self,@RaiseGates);

      // Remove radius enchantments
      foreach i in plActive
      {
         j = First(i);
         if IsClass(j,&Player)
            OR (IsClass(j,&Monster) AND NOT ((Send(j,@GetBehavior) & AI_NPC)))
         {
            foreach k in Send(j,@GetRadiusEnchantments)
            {
               Send(Nth(k,2),@RemoveEnchantment,#who=j,#state=Nth(k,3));
            }
         }
      }

      Send(self,@SetMonsterGeneration,#bValue=FALSE);
      Send(self,@CheckBehindBars);
      // Remove room enchantments
      Send(self,@RemoveAllEnchantments);
      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_Huzzah_Sound);

      return;
   }

   ArenaCommenceFight()
   {
      Send(self,@LowerGates);
      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_gong_sound);

      return;
   }

   ArenaStartTournament(marshal = $)
   {
      Send(self,@SomeoneSaid,#string=SurvivalArena_start_tournament,
            #type=SAY_MESSAGE,#what=self);
      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_Fanfare_Sound);
      pbNoReagents = FALSE;

      return;
   }

   ArenaEndTournament(marshal = $)
   {
      Send(self,@SomeoneSaid,#string=SurvivalArena_end_tournament,
            #type=SAY_MESSAGE,#what=self);
      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_Fanfare_Sound);
      pbNoReagents = TRUE;

      return;
   }

   ArenaRealDeath()
   "Admins can activate real death."
   {
      return pbRealdeath;
   }

   CheckBehindBars()
   {
      local i, iSectorID;

      foreach i in Send(poWatcher,@GetCombatantList)
      {
         iSectorID = Send(i,@GetSectorIDAtObject);

         if IsClass(i,&Player)
            AND iSectorID = SECTOR_ID_BEHIND_BARS
               OR iSectorID = SECTOR_ID_BEHIND_BARS_WATER
         {
            Send(self,@Teleport,#what=i,#goinplay=TRUE);
         }
      }

      return;
   }

   RaiseGates()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_BARS,
            #animation=ANIMATE_FLOOR_LIFT,#height=350,#speed=30);

      return;
   }

   LowerGates()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_BARS,
            #animation=ANIMATE_FLOOR_LIFT,#height=252,#speed=30);

      return;
   }

   RaiseMaze(maze = 14, sector = 0, height = 192)
   {
      Send(self,@RaiseMazeA);
      Send(self,@RaiseMazeB);
      Send(self,@RaiseMazeC);
      Send(self,@RaiseMazeD);
      Send(self,@RaiseStairs);

      return;
   }

   RaiseMazeA()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_A,#animation=ANIMATE_FLOOR_LIFT,
            #height=PILLAR_A_HEIGHT,#speed=32);

      return;
   }

   RaiseMazeB()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_B,#animation=ANIMATE_FLOOR_LIFT,
            #height=PILLAR_BC_HEIGHT,#speed=32);

      pbIsMazeBDown = FALSE;

      if (piRoom_flags & ROOM_SNOWING)
      {
         Send(self,@RemoveTextureChange,#id=16);
      }

      return;
   }

   RaiseMazeC()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_C,#animation=ANIMATE_FLOOR_LIFT,
            #height=PILLAR_BC_HEIGHT,#speed=32);

      pbIsMazeCDown = FALSE;

      if (piRoom_flags & ROOM_SNOWING)
      {
         Send(self,@RemoveTextureChange,#id=17);
      }

      return;
   }

   RaiseMazeD()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_D,#animation=ANIMATE_FLOOR_LIFT,
            #height=PILLAR_D_HEIGHT,#speed=32);

      return;
   }

   RaiseStairs()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_A,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_A_HEIGHT,#speed=32);
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_B,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_B_HEIGHT,#speed=32);
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_C,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_C_HEIGHT,#speed=32);
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_D,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_D_HEIGHT,#speed=32);
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_E,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_E_HEIGHT,#speed=32);
      Send(self,@SetSector,#sector=SECTOR_ID_STAIRS_F,#animation=ANIMATE_FLOOR_LIFT,
            #height=STAIRS_F_HEIGHT,#speed=32);

      return;
   }

   LowerMaze(sector=0)
   "If a sector is specified, just lower that sector.  Otherwise, lower 'em all."
   {
      Send(self,@LowerMazeA);
      Send(self,@LowerMazeB);
      Send(self,@LowerMazeC);
      Send(self,@LowerMazeD);
      Send(self,@LowerStairs);

      return;
   }

   LowerMazeA()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_A,#animation=ANIMATE_FLOOR_LIFT,
            #height=GROUND_HEIGHT,#speed=32);

      return;
   }

   LowerMazeB()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_B,#animation=ANIMATE_FLOOR_LIFT,
            #height=GROUND_HEIGHT,#speed=32);

      pbIsMazeBDown = TRUE;

      if (piRoom_flags & ROOM_SNOWING)
      {
         Send(self,@ChangeTexture,#id=16,#new_texture=61016,
               #flags=CTF_BELOWWALL);
      }

      return;
   }

   LowerMazeC()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_C,#animation=ANIMATE_FLOOR_LIFT,
            #height=GROUND_HEIGHT,#speed=32);

      pbIsMazeCDown = TRUE;

      if (piRoom_flags & ROOM_SNOWING)
      {
         Send(self,@ChangeTexture,#id=17,#new_texture=61016,
               #flags=CTF_BELOWWALL);
      }

      return;
   }

   LowerMazeD()
   {
      Send(self,@SetSector,#sector=SECTOR_ID_PILLAR_D,#animation=ANIMATE_FLOOR_LIFT,
            #height=GROUND_HEIGHT,#speed=32);

      return;
   }

   LowerStairs()
   {
      local i;

      for (i = SECTOR_ID_STAIRS_A; i <= SECTOR_ID_STAIRS_F; ++i)
      {
         Send(self,@SetSector,#sector=i,#animation=ANIMATE_FLOOR_LIFT,
               #height=GROUND_HEIGHT,#speed=32);
      }

      return;
   }

   StartSnow(bOnGround=TRUE)
   {
      local i;

      // Check if we can have weather effects here.
      if NOT pbWeatherEffects
      {
         return;
      }

      // If there's a sandstorm weather effect here, clear it.
      if Send(self,@CheckRoomFlag,#flag=ROOM_SANDSTORM)
      {
         Send(self,@EndSandstorm);
      }

      if bOnGround
         AND pbSnowGroundTexture
      {
         Send(self,@ChangeTexture,#id=0,#new_texture=61015,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=2,#new_texture=61015,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=3,#new_texture=61015,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=4,#new_texture=61015,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=5,#new_texture=61016,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=10,#new_texture=61017,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=11,#new_texture=61017,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=14,#new_texture=61017,#flags=CTF_FLOOR);

         for (i = SECTOR_ID_PILLAR_A; i <= SECTOR_ID_PILLAR_D; ++i)
         {
            Send(self,@ChangeTexture,#id=i,#new_texture=61015,#flags=CTF_FLOOR);
         }
         for (i = SECTOR_ID_STAIRS_A; i <= SECTOR_ID_STAIRS_F; ++i)
         {
            Send(self,@ChangeTexture,#id=i,#new_texture=61015,#flags=CTF_FLOOR);
         }

         Send(self,@ChangeTexture,#id=15,#new_texture=61016,
               #flags=CTF_BELOWWALL);

         if (pbIsMazeBDown)
         {
            Send(self,@ChangeTexture,#id=16,#new_texture=61016,
                  #flags=CTF_BELOWWALL);
         }
         if (pbIsMazeCDown)
         {
            Send(self,@ChangeTexture,#id=17,#new_texture=61016,
                  #flags=CTF_BELOWWALL);
         }

         // Stop water scroll effect and remove depth.
         Send(self,@SetSectorFlags,#sector=10,#depth=SF_DEPTH0,
               #scrollSpeed=SCROLL_NONE);
         Send(self,@SetSectorFlags,#sector=11,#depth=SF_DEPTH0,
               #scrollSpeed=SCROLL_NONE);
         Send(self,@SetSectorFlags,#sector=14,#depth=SF_DEPTH0,
               #scrollSpeed=SCROLL_NONE);
      }

      Send(self,@SetRoomFlag,#flag=ROOM_SNOWING,#value=TRUE);
      Send(self,@WeatherChanged);

      return;
   }

   EndSnow(override=FALSE)
   "Use override if rooms have manually placed textures."
   {
      local i;

      if Send(self,@CheckRoomFlag,#flag=ROOM_SNOWING)
      {
         Send(self,@SetRoomFlag,#flag=ROOM_SNOWING,#value=FALSE);
         Send(self,@WeatherChanged);
      }

      if pbSnowGroundTexture
         OR override
      {
         Send(self,@RemoveTextureChange,#id=0);
         Send(self,@RemoveTextureChange,#id=2);
         Send(self,@RemoveTextureChange,#id=3);
         Send(self,@RemoveTextureChange,#id=4);
         Send(self,@RemoveTextureChange,#id=5);
         Send(self,@RemoveTextureChange,#id=10);
         Send(self,@RemoveTextureChange,#id=11);
         Send(self,@RemoveTextureChange,#id=14);

         for (i = SECTOR_ID_PILLAR_A; i <= SECTOR_ID_PILLAR_D; ++i)
         {
            Send(self,@RemoveTextureChange,#id=i);
         }
         for (i = SECTOR_ID_STAIRS_A; i <= SECTOR_ID_STAIRS_F; ++i)
         {
            Send(self,@RemoveTextureChange,#id=i);
         }

         // Remove from small vertical ledges.
         Send(self,@RemoveTextureChange,#id=15);
         Send(self,@RemoveTextureChange,#id=16);
         Send(self,@RemoveTextureChange,#id=17);

         // Reset sector flag changes to water.
         Send(self,@RemoveSectorFlagChange,#id=10);
         Send(self,@RemoveSectorFlagChange,#id=11);
         Send(self,@RemoveSectorFlagChange,#id=14);
      }

      return;
   }

   // Monster specific stuff
   SetupMonsterWave()
   {
      Send(self,@CheckBehindBars);
      Send(self,@RaiseGates);

      return;
   }

   ArenaMonsterWave(iLevel_Min = 20, iLevel_Max = 100, spawn_max = 1)
   {
      local i, lTemp, iMonsterLevel, lMonsters, iLevel;

      iLevel = 5;
      piLevel = iLevel;

      if (iLevel % 10) = 0
      {
        Send(self,@GenerateBoss);
      }
      else if (iLevel % 5) = 0
      {
        Send(self,@GenerateBoss,#bMiniBoss=TRUE);
      }

      foreach i in Send(SYS,@GetMonsterTemplates)
      {
        iMonsterLevel = Send(i,@GetLevel);
        //if Send(i,@IsArenaMonster)
        //    AND iMonsterLevel >= iLevel_Min
        //    AND iMonsterLevel <= iLevel_Max
        //{
        //    if NOT FindListElem(plBosses,GetClass(i))
        //    {
        //        lTemp = Cons(i,lTemp);
        //    }
        //}
      }

      if lTemp <> $
      {
         foreach i in lTemp
         {
            lMonsters = Cons([GetClass(i),100 / Length(lTemp)],lMonsters);
         }

         if lMonsters <> $
         {
            plMonsters = lMonsters;
            piMonster_count_max = spawn_max;
            piMonster_adjusted_max = spawn_max;
         }
      }

      Send(self,@SomethingWaveRoom,#wave_rsc=SurvivalArena_gong_sound);
      Send(self,@LowerGates);

      return;
   }

   TryCreateMonster()
   {
      propagate;
   }

   GenerateMonster(oMonster=$, iRow=0, iCol=0 )
   {
      local iPatrolRow, iPatrolCol;

      if oMonster <> $
         OR oMonster <> poWatcher
      {
         // Monsters want to go to the middle of the stage
         iPatrolRow = Random(23,38);
         iPatrolCol = Random(35,45);
         Send(oMonster,@GotoCoords,#iRow=iPatrolRow,#iCol=iPatrolCol);
         Send(oMonster,@SetBehaviorFlag,#flag=AI_FIGHT_SINGLEMINDED);
         Send(oMonster,@SetBehaviorFlag,#flag=AI_FIGHT_HYPERAGGRESSIVE);
      }

      propagate;
   }

   GenerateBoss(bMiniBoss=FALSE)
   {
      local cMonster;

      if(bMiniBoss)
      {
         cMonster = Nth(plMiniBosses,Random(1,Length(plMiniBosses)));
      }
      else
      {
         cMonster = Nth(plBosses,Random(1,Length(plBosses)));
      }

      Send(self,@GenerateMonster,#oMonster=Create(cMonster),
            #bStack=TRUE,#piSurvivalLevel=piLevel);

      return;
   }

   IsBoss(what=$)
   {
      if what <> $
      {
         return FindListElem(plBosses,GetClass(what)) > 0;
      }

      return FALSE;
   }

   IsMiniBoss(what=$)
   {
      if what <> $
      {
         return FindListElem(plMiniBosses,GetClass(what)) > 0;
      }

      return FALSE;
   }

   AggroMonsters(who=$)
   {
      local i, iCount;

      if IsClass(who,&Monster)
      {
         return FALSE;
      }

      if (IsClass(who,&DM)
            AND Send(who,@PlayerIsImmortal))
         OR Send(who,@IsInCannotInteractMode)
      {
         return;
      }

      iCount = 0;

      foreach i in plActive
      {
         if IsClass(First(i),&Monster)
            AND (NOT Send(First(i),@IsOwnedByPlayer))
            AND Random(1,100) <= AGGRO_CHANCE
         {
            Send(First(i),@TargetSwitch,#what=who,#iHatred=100);
            //Send(First(i),@EnterStateEngage,#target=who,#actnow=True);

            if ++iCount >= AGGRO_MAX
            {
               return;
            }
         }
      }

      return;
   }

   AdjustMaxMonsters()
   {
      piMonster_adjusted_max = piMonster_count_max;

      return piMonster_adjusted_max;
   }

end
////////////////////////////////////////////////////////////////////////////////
