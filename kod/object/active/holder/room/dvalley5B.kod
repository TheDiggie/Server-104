// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
DValley5B is Room

constants:

   include blakston.khd

   HOURS_PER_TOY = 100
   HOUR_MILLI = 3600000

resources:

   include dvalley5b.lkod

   room_dvalley5b = dvalley5b.roo
   room_name_dvalley5b = "Chamber of the Crying Serpent"

   dvalley5b_music = Nec03.ogg

   dv_climb_crates_rsc = "You climb up on the crate."
   dv_dungeon_climb_down_rsc = "You jump down off the crate."
   dv_search_crates_rsc = "You rummage around in an open crate."
   dv_found_in_crate_rsc = "You find something of interest!"

classvars:

   vrName = room_name_dvalley5b

   viTeleport_row = 3
   viTeleport_col = 11

   viTerrain_Type = TERRAIN_NECROPOLIS

   vbIsExpansionRoom = TRUE

properties:

   prRoom = room_dvalley5b
   piRoom_num = RID_DVALLEY_5B
   prMusic = dvalley5b_music

   piBaseLight = 80
   piOutside_factor = 0

   piHoursCounter = HOURS_PER_TOY
   poLastFinder = $
   plFinders = $
   plFind = $

   // Ignore these users for chest prizes.
   // List of [who, timer, hours_left].
   plIgnoreFinders = $
   // Timer will be replaced every hour, so 37hr timer limit doesn't apply.
   piIgnoreHours = 96

messages:

   Delete()
   {
      Send(self,@ClearIgnoreFinders);

      propagate;
   }

   CreateStandardExits()
   {
      plExits = $;

      plExits = Cons([ 2, 24, RID_DVALLEY_TEMPLE, 10, 5, ROTATE_NONE],plExits);
      plExits = Cons([ 3, 24, RID_DVALLEY_TEMPLE, 10, 5, ROTATE_NONE],plExits);
      plExits = Cons([ 5, 15, RID_DVALLEY_5, 37, 20, ROTATE_180],plExits);

      return;
   }

   CreateStandardObjects()
   {
      if plFind = $
      {
         plFind = [ &Tanktop,
                    &ShrunkenHead,
                    &Book,
                    &Rose,
                    &GuildShield,
                    &Prism,
                    &GoldSword,
                    &Thrasher,
                    &Junk ];
      }

      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=30),
           #new_row=1,#new_col=6,#fine_row=44,#fine_col=0);
      Send(self,@NewHold,#what=Create(&DynamicLight,#iColor=LIGHT_FIRE,#iIntensity=30),
           #new_row=1,#new_col=11,#fine_row=44,#fine_col=32);


      Send(self,@NewHold,#what=Create(&OrnamentalObject,#type=OO_HALFSKULL),
           #new_row=1,#new_col=15,#fine_row=48,#fine_col=0,#angle=ANGLE_EAST);
      Send(self,@NewHold,#what=Create(&Skull),
           #new_row=6,#new_col=9,#fine_row=56,#fine_col=56,#angle=ANGLE_EAST);
      Send(self,@NewHold,#what=Create(&OrnamentalObject,#type=OO_HALFSKULL),
           #new_row=3,#new_col=4,#fine_row=48,#fine_col=56,#angle=ANGLE_EAST);
      Send(self,@NewHold,#what=Create(&Skull),
           #new_row=1,#new_col=2,#fine_row=48,#fine_col=56,#angle=ANGLE_EAST);
      Send(self,@NewHold,#what=Create(&OrnamentalObject,#type=OO_HALFSKULL),
           #new_row=6,#new_col=15,#fine_row=8,#fine_col=0,#angle=ANGLE_EAST);

      propagate;
   }

   RecalcLightAndWeather()
   {
      --piHoursCounter;

      propagate;
   }

   SomethingTryGo(what = $,row = $,col = $)
   {
      local find, iNewRow, iNewCol, i, iCount, iLength, iSkip;

      if (row = 5) AND (col = 4)
      {
         Send(SYS,@UtilGoNearSquare,#what=what,#where=self,#new_row=4,#new_col=4);
         Send(what,@MsgSendUser,#message_rsc=dv_climb_crates_rsc);

         return TRUE;
      }

      // Rummaging around in the crate.
      // If it's not the last person who found something, and enough time
      // has elapsed, "find" (create) something of interest for them.
      //
      // The plFind is a list of classes.
      // We create one instance of a randomly chosen class.
      // If it's an item, we give it to them.
      // Some items have special properties, such as random coloring.
      // If it's a monster, we generate it at their feet.

      if (row = 4) AND (col = 4)
      {
         Send(what,@MsgSendUser,#message_rsc=dv_search_crates_rsc);

         // Have to post this here, happens no matter what after the rest.
         Post(self,@RemovePlayerFromCrate,#who=what);

         if what = poLastFinder
            OR Send(self,@IsInIgnoreFinders,#who=what)
         {
            return TRUE;
         }

         if piHoursCounter < 0
         {
            piHoursCounter = HOURS_PER_TOY + Random(0,100) - 50;

            if plFind = $
            {
               return TRUE;
            }

            if Length(plFind) > 0
            {
               find = Nth(plFind,Random(1,Length(plFind)));
            }
            else
            {
               find = plFind;
            }

            if find = $
            {
               return TRUE;
            }

            find = Create(find);

            if find = $
            {
               return TRUE;
            }

            Send(what,@MsgSendUser,#message_rsc=dv_found_in_crate_rsc);
            poLastFinder = what;

            // Keep track of last 150 finders, pop first once it hits limit.
            plFinders = AppendListElem(what, plFinders);
            if (Length(plFinders) > 150)
            {
               plFinders = Rest(plFinders);
            }

            // If they get 3 of the last 10 prizes, give them a delay before
            // they can find another.
            iLength = Length(plFinders);
            if (iLength >= 10)
            {
               iSkip = 0;
               iCount = 0;
               foreach i in plFinders
               {
                  if (++iSkip <= iLength - 10)
                  {
                     continue;
                  }
                  if (i = what)
                  {
                     ++iCount;
                  }
               }

               if (iCount >= 3)
               {
                  Send(self,@AddToIgnoreFinders,#who=what,
                        #iNumHours=piIgnoreHours);
               }
            }

            if IsClass(find,&Item)
            {
               if IsClass(find,&Tanktop)
               {
                  Send(find,@Exotic);
               }
               if IsClass(find,&ShirtBase)
               {
                  Send(find,@Randomize);
               }
               if IsClass(find,&GuildShield)
               {
                  Send(find,@Randomize);
               }

               Send(what,@NewHold,#what=find);
            }

            if IsClass(find,&Monster)
            {
               // Offset the monster a bit so that it appears, instead of
               // trying to fit two things in the same space.
               iNewRow = 4;
               iNewCol = 5;

               if Send(self,@ReqNewHold,#what=find,#new_row=iNewRow,#new_col=iNewCol)
                  AND Send(self,@ReqSomethingMoved,#what=find,#new_row=iNewRow,#new_col=iNewCol)
               {
                  Send(self,@NewHold,#what=find,#new_row=iNewRow,#new_col=iNewCol);
               }
               else
               {
                  Send(find,@Delete);
                  find = $;
               }
            }
         }

         return TRUE;
      }

      propagate;
   }

   RemovePlayerFromCrate(who = $)
   {
      if (who = $
         OR Send(who,@GetOwner) <> self)
      {
         return;
      }

      // Port the player off the crate
      Send(SYS,@UtilGoNearSquare,#what=who,#where=self,#new_row=2,#new_col=5);
      Send(who,@MsgSendUser,#message_rsc=dv_dungeon_climb_down_rsc);

      return;
   }

   SeanceCheck()
   {
      return FALSE;
   }

   IsInIgnoreFinders(who=$)
   {
      return GetListNode(plIgnoreFinders,1,who) <> $;
   }

   AddToIgnoreFinders(who=$,iNumHours=0)
   "Can call with iNumHours to set a timer, or without for permanent addition."
   {
      local lNode, tTimer;

      if (who = $
         OR NOT IsClass(who,&User))
      {
         Debug("Invalid who passed to AddToIgnoreFinders ", who);

         return;
      }

      lNode = GetListNode(plIgnoreFinders,1,who);

      // If they are already there, refresh or delete the timer.
      if (lNode <> $)
      {
         tTimer = Nth(lNode,2);
         if (IsTimer(tTimer))
         {
            DeleteTimer(tTimer);
         }
         if (iNumHours > 0)
         {
            SetNth(lNode,2,CreateTimer(self,@RemoveFromIgnoreFinders,HOUR_MILLI));
            SetNth(lNode,3,iNumHours);
         }
         else
         {
            SetNth(lNode,2,$);
         }
      }
      else if (iNumHours > 0)
      {
         plIgnoreFinders = Cons([who,
            CreateTimer(self,@RemoveFromIgnoreFinders,HOUR_MILLI),iNumHours],
            plIgnoreFinders);
      }
      else
      {
         plIgnoreFinders = Cons([who,$,0],plIgnoreFinders);
      }

      return;
   }

   RemoveFromIgnoreFinders(timer=$,who=$)
   "If called by timer with a set number of hours still to go "
   "(3rd list element) the timer will be replaced."
   {
      local iNumHours, lNode, tTimer;

      if (timer <> $)
      {
         lNode = GetListNode(plIgnoreFinders,2,timer);
         if (lNode = $)
         {
            Debug("Couldn't find timer ", timer, " in ignore list!");

            return;
         }

         // Replace timer if there's still time left.
         iNumHours = Nth(lNode,3) - 1;
         if (iNumHours > 0)
         {
            SetNth(lNode,2,CreateTimer(self,@RemoveFromIgnoreFinders,HOUR_MILLI));
            SetNth(lNode,3,iNumHours);

            return;
         }

         // Finished ignore time, remove.
         SetNth(lNode,2,$);
         plIgnoreFinders = DelListElem(plIgnoreFinders,lNode);
      }
      else if (who <> $)
      {
         lNode = GetListNode(plIgnoreFinders,1,who);
         if (lNode = $)
         {
            Debug("Couldn't find who ", who, " in ignore list!");

            return;
         }
         tTimer = Nth(lNode,2);
         if (IsTimer(tTimer))
         {
            DeleteTimer(tTimer);
         }
         SetNth(lNode,2,$);
         plIgnoreFinders = DelListElem(plIgnoreFinders,lNode);
      }

      return;
   }

   ClearIgnoreFinders()
   {
      local i, tTimer;

      foreach i in plIgnoreFinders
      {
         tTimer = Nth(i,2);
         if (IsTimer(tTimer))
         {
            DeleteTimer(tTimer);
            SetNth(i,2,$);
         }
      }
      plIgnoreFinders = $;

      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
