// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
Item is Object

constants:

   include blakston.khd
   include protocol.khd

   ARMOR_TAKE_DAMAGE_PCT = 75
   
resources:

   include item.lkod

   item_this = "This "
   item_blank_template = "%q"

   // item_desc_template is vrDesc, item attributes, object attributes,
   // variable item appends, item stats, item condition.
   item_desc_template = "%r%r%r%r%r%r%r"
   resource_blank = ""

   item_try_use_cursed_rsc = \
      "As you pick the item up, you feel a will greater than your own "
      "overwhelm your mind!  Not of your own volition, you try to put it on!"

   item_broken_battle = "Your %s shatters in the heat of battle!"
   item_broken_battle_plural = "Your %s shatter in the heat of battle!"
   item_broken_battle_clothing = "Your %s falls into useless tatters!"
   item_broken_battle_clothing_plural = "Your %s fall into useless tatters!"

   itematt_generic = \
      "\n\nAt first glance, it seems quite ordinary, but there is something odd "
      "about it you can't put your finger on."

   nakedleftarm_male = blg.bgf
   nakedrightarm_male = brg.bgf
   nakedleftarm_female = blh.bgf
   nakedrightarm_female = brh.bgf

   item_condition_exc = " is in immaculate condition."
   item_condition_exc_mended = \
      " is in excellent condition, but has been patched before."
   item_condition_good = " is scuffed and slightly worn."
   item_condition_med = " has a few unsightly rips."
   item_condition_poor = " is in tatters, and barely holding together."
   item_condition_broken = " is covered in filth and ripped beyond use."
   item_cond_master = "\n%s%s%s (%i/%i)"
   special_properties_header = \
      "\n\nThis item has the following properties:\n"
   item_stats_range = "%i range\n"
   item_stats_offense = "%i offense rating bonus\n"
   item_stats_armor = "%i armor\n"
   item_stats_defense = "%i defense rating bonus\n"
   item_stats_melee = "%i melee damage bonus\n"
   item_stats_min_dmg = "%i-"
   item_stats_base_dmg = "%r%i base damage\n"
   item_stats_owner_dmg = "%r%i damage in owner's hands\n"
   item_stats_cond_dmg = "%r%i conditional base damage\n"
   item_stats_cond_owner_dmg = "%r%i conditional damage in owner's hands\n"
   item_stats_dmg_bonus = "%i damage bonus\n"
   item_stats_gen_sp = "%i general spellpower\n"
   item_stats_faren_sp = "%i Faren spellpower\n"
   item_stats_riija_sp = "%i Riija spellpower\n"
   item_stats_kran_sp = "%i Kraanan spellpower\n"
   item_stats_jala_sp = "%i Jala spellpower\n"
   item_stats_shal_sp = "%i Shal'ille spellpower\n"
   item_stats_qor_sp = "%i Qor spellpower\n"
   item_stats_jala_instrument_sp = "%i Jala instrument power\n"
   item_stats_craft_sp = "%i Crafting spellpower\n"
   item_stats_resistance = "%i%% %s\n"
   item_stats_dmg_type = "Deals %s damage\n"

   half_broken    = "~B~yYour %s is damaged!"
   almost_broken  = "~B~yYour %s is almost broken!"
   very_broken    = "~B~yYour %s is about to break!"

   item_weight    = "%i weight and %i bulk\n"
   item_bulk      = "%i bulk\n"

   item_cast_spell = "\n\nEmblazoned with mystic symbols, this %s grants its wielder the unyielding force of %s on its user."

classvars:

   vrItem_broken = item_broken_battle

   vrPoss_article = item_this
   viUse_type = ITEM_CANT_USE
   viItem_type = ITEMTYPE_MISC

   viUse_amount = 1

   viHits_init_min = 1
   viHits_init_max = 1

   viBulk = 10
   viWeight = 10

   viValue_average = 10

   viGround_group = 1
   viInventory_group = 1
   viBroken_group = $    // if set to nil, no group exists

   // How much this item will help or hinder spell usage.
   viSpell_modifier = 0

   vrIcon_male       = $
   vrIcon_female     = $
   vrLeftArm_male    = $
   vrLeftArm_female  = $
   vrRightArm_male   = $
   vrRightArm_female = $
   vrLegs_male       = $
   vrLegs_female     = $

   vbShow_condition =  FALSE
   vrCondition_exc =   item_condition_exc
   vrCondition_exc_mended = item_condition_exc_mended
   vrCondition_good =  item_condition_good
   vrCondition_med =   item_condition_med
   vrCondition_poor =  item_condition_poor
   vrCondition_broken = item_condition_broken
   
   // Items may have a different appearance once revealed. Values are zero if not applicable.
   viUnrevealedColor = 0
   viRevealedColor = 0

   viDefense_base = 0 
   viAttack_base  = 0
   viRefined      = $
   viRefinedAt    = $
   viRefineSpell  = $
   
properties:

   viObject_flags = OF_GETTABLE
   piHits_init = 0
   piHits = 0

   piDefense_bonus = 0
   piHitBonus = 0

   plItem_attributes = $
   piItem_flags = 0
   piOriginalColor = 0

   piUsed = 2
   pbIn_use = FALSE

   // Item is colored
   pbColored = FALSE
   piSpecial = $

   piIndestructible = FALSE

   viMiningBonus     = 0
   viGatheringBonus  = 0
   viLoggingBonus    = 0
   viSkinningBonus   = 0

   viHalf   = FALSE
   viAlmost = FALSE
   viVery   = FALSE

   poCrafter      = $
   poSpell        = $

messages:

   Constructor(corpse=$, oDMCreator=$)
   {
      local iHits_average, oItemAtt;

      piHits_init = Random(viHits_init_min,viHits_init_max);
      piHits = piHits_init;
      
      if corpse <> $
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_CORPSEPOINTER);
         if Send(oItemAtt,@ReqAddToItem,#oItem=self)
         {
            Send(oItemAtt,@AddToItem,#oItem=self,#state1=corpse);
         }
      }

      if viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = 0
      {
         Send(self,@SetPaletteTranslation,#translation=viUnrevealedColor);
      }

      if (oDMCreator <> $
         AND NOT IsClass(self,&NumberItem))
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_DM_CREATED);
         if Send(oItemAtt,@ReqAddToItem,#oItem=self)
         {
            Send(oItemAtt,@AddToItem,#oItem=self,#state1=oDMCreator);
         }
      }

      piOriginalColor = piItem_flags;

      propagate;
   }

   SetItemPlayerFlag(who=$,iSpecial=$)
   {
      iSpecial = piSpecial;

      if(piSpecial <> $)
      {
         Send(poOwner,@SetPlayerFlag,#flag=iSpecial,#value=TRUE);
      }

      return;
   }

   AppendStatsDesc()
   "This is the statistics for the weapon, such as damage, armor, "
   "resists and spellpower added."
   {
      local i, bFoundProperties, iHigh_level, n, iFarenPower, iRiijaPower,
            iKraananPower, iJalaPower, iShalPower, iQorPower, iInstrumentPower,
            iNum, iMinDamage, iMinDamageOwner, iAttackType, oItemAtt,
            lResists, iLen, iCraftingPower;

      // This message 'telescopes' resources into the 5th %r of
      // item_desc_template. There are 16 different stats we can add;
      // when we first add a stat to be displayed we add a template with
      // the correct number of %r formatters to match the number of stats
      // remaining (plus one for the special_properties_header). If a stat
      // is missing after we have already added the headers, add a blank
      // resource ("") in its place. If new stats are added to this message,
      // the system_rsc_template_<number> resources should be updated
      // accordingly.

      // bFoundProperties is TRUE if we've already added a property. Use this
      // to lower the amount of resources we send to only those necessary.
      bFoundProperties = FALSE;

      if Send(self,@GetRange) <> 0
      {
         AddPacket(4,system_rsc_template_17, 4,special_properties_header,
                   4,item_stats_range, 4,Send(self,@GetRange)/FINENESS);
         bFoundProperties = TRUE;
      }

      if Send(self,@GetHitBonus) <> 0
      {
         if bFoundProperties
         {
            // bFoundProperties TRUE, already added headers.
            AddPacket(4,item_stats_offense, 4,Send(self,@GetHitBonus));
         }
         else
         {
            // bFoundProperties FALSE, add headers.
            AddPacket(4,system_rsc_template_16, 4,special_properties_header,
                      4,item_stats_offense, 4,Send(self,@GetHitBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         // bFoundProperties TRUE and didn't add this particular stat,
         // so add a blank resource in its place.
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDamageReduction) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_armor, 4,Send(self,@GetDamageReduction));
         }
         else
         {
            AddPacket(4,system_rsc_template_15, 4,special_properties_header,
                      4,item_stats_armor, 4,Send(self,@GetDamageReduction));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDefenseBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_defense, 4,Send(self,@GetDefenseBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_14,4,special_properties_header,
                      4,item_stats_defense, 4,Send(self,@GetDefenseBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMeleeDamageBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_melee, 4,Send(self,@GetMeleeDamageBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_13, 4,special_properties_header,
                      4,item_stats_melee, 4,Send(self,@GetMeleeDamageBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iMinDamage = Send(self,@GetMinDamage);
      if iMinDamage <> 0
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_12, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxDamage) <> iMinDamage
         {
            AddPacket(4,item_stats_base_dmg,4,item_stats_min_dmg,
                      4,iMinDamage,4,Send(self,@GetMaxDamage));
         }
         else
         {
            AddPacket(4,item_stats_base_dmg,4,system_blank_resource,
                      4,iMinDamage);
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iMinDamageOwner = Send(self,@GetMinDamageWithOwnerStats);
      if iMinDamageOwner <> 0
         AND iMinDamageOwner <> iMinDamage
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_11, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxDamageWithOwnerStats)
            <> iMinDamageOwner
         {
            AddPacket(4,item_stats_owner_dmg, 4,item_stats_min_dmg,
                      4,iMinDamageOwner,4,Send(self,@GetMaxDamageWithOwnerStats));
         }
         else
         {
            AddPacket(4,item_stats_owner_dmg, 4,system_blank_resource,
                      4,iMinDamageOwner);
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMinSpecialDamage) <> 0
         AND Send(self,@GetMinSpecialDamage) <> iMinDamage
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_10, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxSpecialDamage) <> Send(self,@GetMinSpecialDamage)
         {
            AddPacket(4,item_stats_cond_dmg, 4,item_stats_min_dmg,
                      4,Send(self,@GetMinSpecialDamage),
                      4,Send(self,@GetMaxSpecialDamage));
         }
         else
         {
            AddPacket(4,item_stats_cond_dmg, 4,system_blank_resource,
                      4,Send(self,@GetMinSpecialDamage));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMinSpecialDamageWithOwnerStats) <> 0
         AND Send(self,@GetMinSpecialDamageWithOwnerStats)
            <> Send(self,@GetMinSpecialDamage)
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_9, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxSpecialDamageWithOwnerStats)
            <> Send(self,@GetMinSpecialDamageWithOwnerStats)
         {
            AddPacket(4,item_stats_cond_owner_dmg, 4,item_stats_min_dmg,
                      4,Send(self,@GetMinSpecialDamageWithOwnerStats),
                      4,Send(self,@GetMaxSpecialDamageWithOwnerStats));
         }
         else
         {
            AddPacket(4,item_stats_cond_owner_dmg,4,system_blank_resource,
                      4,Send(self,@GetMinSpecialDamageWithOwnerStats));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDamageBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_dmg_bonus, 4,Send(self,@GetDamageBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_8, 4,special_properties_header,
                      4,item_stats_dmg_bonus, 4,Send(self,@GetDamageBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iFarenPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_LIGHT));
      iRiijaPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_BLINK));
      iKraananPower = Send(self,@GetSpellModifier,
                           #oSpell=Send(SYS,@FindSpellByNum,#num=SID_BLESS));
      iJalaPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_MIRTH));
      iShalPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_SEANCE));
      iQorPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_DARKNESS));
      iCraftingPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_CRAFTAPPAREL));

      iInstrumentPower = 0;
      if IsClass(self,&Instrument)
      {
         iInstrumentPower = Send(self,@GetInstrumentLevel);
      }

      if iFarenPower <> 0
         OR iRiijaPower <> 0
         OR iKraananPower <> 0
         OR iJalaPower <> 0
         OR iShalPower <> 0
         OR iQorPower <> 0
         OR iInstrumentPower <> 0
         OR iCraftingPower <> 0
      {
         if iFarenPower = iRiijaPower
            AND iRiijaPower = iKraananPower
            AND iKraananPower = iJalaPower
            AND iJalaPower = iShalPower
            AND iShalPower = iQorPower
            AND iQorPower = iCraftingPower
            AND iFarenPower <> 0
         {
            if NOT bFoundProperties
            {
               AddPacket(4,system_rsc_template_7, 4,special_properties_header);
               bFoundProperties = TRUE;
            }
            AddPacket(4,item_stats_gen_sp, 4,iFarenPower);
         }
         else
         {
            if NOT bFoundProperties
            {
               AddPacket(4,system_rsc_template_7, 4,special_properties_header);
               bFoundProperties = TRUE;
            }

            AddPacket(4,system_rsc_template_8);

            if iFarenPower <> 0
            {
               AddPacket(4,item_stats_faren_sp, 4,iFarenPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iRiijaPower <> 0
            {
               AddPacket(4,item_stats_riija_sp, 4,iRiijaPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iKraananPower <> 0
            {
               AddPacket(4,item_stats_kran_sp, 4,iKraananPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iJalaPower <> 0
            {
               AddPacket(4,item_stats_jala_sp, 4,iJalaPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iShalPower <> 0
            {
               AddPacket(4,item_stats_shal_sp, 4,iShalPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iQorPower <> 0
            {
               AddPacket(4,item_stats_qor_sp, 4,iQorPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iCraftingPower <> 0
            {
               AddPacket(4,item_stats_craft_sp, 4,iCraftingPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iInstrumentPower <> 0
            {
               AddPacket(4,item_stats_jala_instrument_sp, 4,iInstrumentPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      lResists = Send(self,@GetCurrentResistances);
      if lResists <> $
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_6, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         iLen = Length(lResists);
         if iLen > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,#iNum=iLen));
         }

         foreach i in lResists
         {
            AddPacket(4,item_stats_resistance, 4,Nth(i,2),
                      4,Send(SYS,@GetResistanceName,#type=First(i)));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iAttackType = Send(self,@GetAttackType);
      if iAttackType <> 0
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_6, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         if Length(Send(SYS,@GetAttackTypeList)) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                           #iNum=Length(Send(SYS,@GetAttackTypeList))));
         }

         foreach i in Send(SYS,@GetAttackTypeList)
         {
            if (iAttackType & i)
            {
               AddPacket(4,item_stats_dmg_type,
                         4,Send(SYS,@GetAttackDamageTypeName,#type=i));
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iAttackType = Send(self,@GetAttackSpell);
      if iAttackType <> 0
      {
         iLen = Length(Send(SYS,@GetSpellTypeList));
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_4, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         if iLen > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,#iNum=iLen));
         }

         foreach i in Send(SYS,@GetSpellTypeList)
         {
            if (iAttackType & i)
            {
               AddPacket(4,item_stats_dmg_type,
                         4,Send(SYS,@GetSpellDamageTypeName,#type=i));
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if plItem_attributes <> $
      {
         iLen = Length(plItem_attributes);
         if iLen > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,#iNum=iLen));
         }

         foreach i in plItem_attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

            if NOT bFoundProperties
               AND Send(oItemAtt,@GetInfoDesc) <> system_blank_resource
            {
               AddPacket(4,system_rsc_template_3, 4,special_properties_header);
               bFoundProperties = TRUE;
            }

            // Each item attribute can add a description, or possibly
            // a blank resource if it isn't identified.
            Send(oItemAtt,@AppendDescInfo,#oItem=self,#compound=First(i));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if viWeight <> $
      {
         if bFoundProperties = FALSE
         {
            AddPacket(4,system_rsc_template_2, 4,special_properties_header);
            AddPacket(4,item_weight,4,viWeight,4,viBulk);
            bFoundProperties = TRUE;
         }
         else
         {
            AddPacket(4,item_weight,4,viWeight,4,viBulk);
         }
      }
      
      return;
   }

   GetMinDamageWithOwnerStats()
   {
      return 0;
   }

   GetMaxDamageWithOwnerStats()
   {
      return 0;
   }

   GetMinSpecialDamageWithOwnerStats()
   {
      return 0;
   }

   GetMaxSpecialDamageWithOwnerStats()
   {
      return 0;
   }

   GetAttackType()
   {
      return 0;
   }

   GetAttackSpell()
   {
      return 0;
   }

   GetMinDamage()
   {
      return 0;
   }

   GetMaxDamage()
   {
      return 0;
   }

   // Some weapons and spells have special conditions, like nerudite arrows that can shatter
   GetMinSpecialDamage()
   {
      return 0;
   }

   GetMaxSpecialDamage()
   {
      return 0;
   }

   GetRange()
   {
      return 0;
   }

   GetHitBonus()
   {
      return 0;
   }

   GetDefenseBonus()
   {
      return 0;
   }

   GetMeleeDamageBonus()
   {
      return 0;
   }

   GetDamageBonus()
   {
      return 0;
   }

   GetDamageReduction()
   {
      return 0;
   }

   GetAttributes()
   {
      return plItem_Attributes;
   }

   GetResistanceModifiers()
   {
      return $;
   }

   DoBaseDesc()
   "Items can override this to provide a more detailed base description."
   {
      AddPacket(4,vrDesc);

      return;
   }

   ShowDesc(who=$,bShowAll = FALSE)
   {
      local bAlreadyBlind, bIdentified, oItemAtt, i, iNum, oSpell;

      bAlreadyBlind = FALSE;

      AddPacket(4,item_desc_template);

      Send(self,@DoBaseDesc);


      if Send(self,@HasAttribute,#ItemAtt=IA_MISDIRECTION)
         AND NOT bShowAll
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_MISDIRECTION);
         Send(oItemAtt,@AppendMisdirectedDesc,#oItem=self,
               #lData=Send(self,@GetAttributeData,#ItemAtt=IA_MISDIRECTION));
      }
      else if plItem_Attributes <> $
      {
         // Support for displaying up to 12 itematts.
         if Length(plItem_Attributes) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                              #iNum=Length(plItem_Attributes)));
         }

         foreach i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            bIdentified = Send(self,@GetIDStatusFromCompound,
                              #compound=First(i));

            if NOT (bIdentified OR bShowAll)
            {
               if bAlreadyBlind
               {
                  AddPacket(4,system_blank_resource);
               }
               else
               {
                  AddPacket(4,itematt_generic);
                  bAlreadyBlind = TRUE;
               }
            }
            else
            {
               Send(oItemAtt,@AppendDesc,#oItem=self,#lData=i,#who=who);
            }
         }
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      if plObject_attributes = $
      {
         AddPacket(4,system_blank_resource);
      }
      else
      {
         // Support for displaying up to 12 objectatts.
         if Length(plObject_attributes) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                              #iNum=Length(plObject_attributes)));
         }

         foreach i in plObject_attributes
         {
            Send(i,@AttributeDesc);
         }
      }

      if poSpell <> $ AND NOT IsClass(self,&Prism)
      {
         oSpell = Send(SYS,@FindSpellByNum,#Num=poSpell);
         AddPacket(4,item_cast_spell, 4,Send(self,@GetName), 4,Send(oSpell,@GetName));
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }
      
      // Special things for number items, etc.
      Send(self,@AppendDesc);
      Send(self,@AppendStatsDesc);
      Send(self,@AppendItemCondition);

      return;
   }

   AppendDesc()
   {
      AddPacket(4,system_blank_resource);

      return;
   }

   AppendItemCondition()
   {
      local iHit_Percent, rItem_condition;

      if vbShow_Condition
         AND piHits_init > 0
      {
         rItem_condition = vrCondition_exc;
         iHit_Percent = (100 * piHits) / piHits_init;
         if iHit_Percent > 90
         {
            // If item is worse than what can be found in the wild, describe it
            //  as being "patched".
            if piHits_init >= viHits_init_min
            {
               rItem_condition = vrCondition_exc;
            }
            else
            {
               rItem_condition = vrCondition_exc_mended;
            }
         }
         else if iHit_Percent > 65
         {
            ritem_condition = vrCondition_good;
         }
         else if iHit_Percent > 30
         {
            ritem_condition = vrCondition_med;
         }
         else if piHits > 0
         {
            ritem_condition = vrCondition_poor;
         }
         else
         {
            ritem_condition = vrCondition_broken;
         }

         AddPacket(4,item_cond_master, 4,vrPoss_Article, 4,Send(self,@GetName),
                   4,rItem_condition,4,piHits,4,piHits_init);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   ReqRepair()
   {
      return FALSE;
   }

   DestroyDisposable()
   {
      if Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         return;
      }
      
      Send(self,@Delete);
      
      return;
   }

   GetItemUseType()
   {
      if piHits <= 0
      {
         return ITEM_BROKEN;
      }
      
      return viUse_type;
   }

   GetItemUseAmount()
   {
      return viUse_amount;
   }

   GetInitValue()
   {
      return viValue_average;
   }

   GetValue()
   {
      local iPercent, iValue, iFinal, i, oItemAtt, iNum;

      // Okay, new way of figuring value, considering 
      // max_hits, current_max_hits, and hits.
      // The basic formula follows this curve:
      //
      //              Hits
      //             Y   .8Y   .6Y   .4Y   .2Y
      // Max_hits  -----------------------------            
      //    Y        X   .80X  .60X  .40X  .20X
      //   .8Y           .64X  .48X  .32X  .16X
      //   .6Y                 .36X  .24X  .12X
      //   .4Y                       .16X  .08X
      //   .2Y                             .04X
      //
      //    Y = viHits_init_max (max_hits before casting 'mend')
      //    X = viAverage_value
      //
      // Translated:  An item whose piInit_hits is 80// of viHits_init_max
      //              and whose piHits is equal to that amount has a value equal
      //              to 64// of its standard value.

      iPercent = (100*piHits_init*piHits)/(viHits_init_max*viHits_init_max);
      iValue = Send(self,@GetInitValue);
      
      iFinal = (iValue * iPercent)/100;
      iFinal = bound(iFinal,10,iValue);      
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iFinal = Send(oItemAtt,@AdjustPrice,#value=iFinal,
                       #iCompound=First(i));
      }
      
      return iFinal;
   }

   GetMaxHits()
   {
      return piHits_init;
   }

   GetHits()
   {
      return piHits;
   }

   SetMaxHits(number = $)
   {
      if number = $
      {  
         return;
      }

      piHits_init = number;

      return;   
   }

   SetHits(number = $)
   {
      if number = $
      {
         return;
      }

      piHits = number;

      return;
   }

   NewOwner(what = $)
   {
      local lData;

      // If the person who is supposed to pick up an item picks up 
      //  the item, then remove the corpsepointer.
          
      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {  
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }      

      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         lData = Send(self,@GetAttributeData,#ItemAtt=IA_BONDED);
         Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),@BondedItemReport,
              #BondedItem=self,#BondedPlayer=Nth(lData,2),
              #BondedItemOwner=what);
      }      

      if what <> $ 
         AND (IsClass(what,&User)) 
         AND (Send(self,@IsCursed)) 
         AND (NOT Send(what,@PlayerIsImmortal))
      {
         Send(what,@MsgSendUser,#message_rsc=item_try_use_cursed_rsc);
         Post(what,@TryUseItem,#what=self);
      }

      propagate;
   }

   ReqUseSomething(what = $)
   {
      return TRUE;
   }

   NewUsed(what=$, iSpecial = $)
   {
      local oRoom, oSpell;

      iSpecial = piSpecial;

      pbIn_use = TRUE;

      Send(self,@DoPlayerArt);
      If IsClass(poOwner,&Player)
      {
         Post(poOwner,@RefreshPlayerVisualGear);
      }
      
      if(iSpecial <> $)
      {
         oRoom = Send(poOwner, @GetOwner);
         Send(poOwner,@SetPlayerFlag,#flag=iSpecial,#value=TRUE);
      }

      if poSpell <> $
      {
         oSpell = Send(SYS,@FindSpellByNum,#Num=poSpell);

         if NOT Send(what,@IsEnchanted,#what=oSpell)
         {
	            Send(oSpell,@CastSpell,#who=what,#iSpellPower=99,#bItemCast=TRUE,#SpecialItem=TRUE);
         }
      }

      return;
   }

   UserLogoff()
   "Called when we're used by someone, and they logoff."
   {
      return;
   }

   UserLogon()
   "Called when we're used by someone, and they logon."
   {
      return;
   }

   ReqUse()
   "Called when the player tries to use the item"
   {
      local i, oItemAtt, iNum;
          
      /// check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   ReqUnuse()
   "Called when the player tries to unuse the item"
   {
      local i, oItemAtt, iNum;
          
      // Check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUnuse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   NewUnused(what=$, iSpecial = $)
   {
      local oSpell;

      iSpecial = piSpecial;

      pbIn_use = FALSE;
	  
      Send(self,@UndoPlayerArt);

      if(piSpecial <> $)
      {
         Send(poOwner,@SetPlayerFlag,#flag=piSpecial,#value=FALSE);
      }

      if poSpell <> $
      {
         oSpell = Send(SYS,@FindSpellByNum,#Num=poSpell);

         if Send(what,@IsEnchanted,#what=oSpell)
         {
            Send(what,@RemoveEnchantment,#what=oSpell);
         }
      }

      return;
   }

   ReqNewOwner(what=$)
   {      
      return ((poOwner = $) OR Send(poOwner,@ReqLeaveHold,#what=self));
   }

   ReqLeaveOwner()
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqLeaveOwner,#oItem=self)
         {
            return FALSE;
         }
      }
      
      propagate;
   }

   ReqNewOwnerAttributes(who=$,type = 0)
   "This checks to see if there is anything that prevents a player from "
   "picking up an item due to that item's attributes alone.  Note: these "
   "attributes are responsible for providing error code."
   {
      local i, oItemAtt, iNum;

      // Type 0 is get
      // Type 1 is offer

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@CanGetAffectedItem,#who=who,#lData=i,
                     #oItem=self,#type=type)
         {
            return FALSE;
         }         
      }
      
      return TRUE;
   }
   
   SendAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viGround_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendLookAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);

      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);

      }
      
      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryOverlays()
   {
      AddPacket(1, 0);
      
      return;
   }

   SendOverlayInformation()
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation);
      
      return;
   }

   GetNumberOverlays()
   {
      // Most overlay items only offer one overlay.
      //  Some items like weapons and bows may offer two.
      return 1;
   }

   IsCursed()
   "This returns TRUE if a RemoveCurse spell should unuse the item."
   "Since an ItemAtt can curse an item, go through those to check."
   {
      local i, oItemAtt, iNum;
                
      // Check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if Send(oItemAtt,@ItemIsCursed,#oItem=self)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   ModifyDefensePower(defense_power = 0)
   "Gives the defensive bonus"
   {
      return defense_power;
   }

   DefendingHit(who = $,what = $)
   {
      if piIndestructible = TRUE
      {
         return;
      }

      // Set to 75// currently
      if Random(1,100) < ARMOR_TAKE_DAMAGE_PCT
      {
         --piHits;
      }


      if pihits >= (piHits_init/2) AND viHalf = TRUE
      {
         viHalf = FALSE;
         viAlmost = FALSE;
         viVery = FALSE;

         return;
      }

      if viHalf = FALSE AND pihits <= (piHits_init/2)
      {
         Send(poOwner,@MsgSendUser,#message_rsc=half_broken,#parm1=Send(self,@getname));

         viHalf = TRUE;

         return;
      }
      
      if viAlmost = FALSE AND pihits <= (piHits_init/4)
      {
         Send(poOwner,@MsgSendUser,#message_rsc=almost_broken,#parm1=Send(self,@getname));
         
         viAlmost = TRUE;

         return;
      }

      if viVery = FALSE AND pihits <= (piHits_init/10)
      {
         Send(poOwner,@MsgSendUser,#message_rsc=very_broken,#parm1=Send(self,@getname));
         
         viVery = TRUE;

         return;
      }

      if piHits <= 0
      {
         Send(self,@ItemBrokenInBattle);
      }
      
      return;
   }

   ItemBrokenInBattle()
   {
      local i, oItemAtt, iNum;

      // Remove itematts from us, since we're not gonna use 'em anymore.
      // This also lets cursed items finally remove themselves from us.
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }
   
      Send(poOwner,@SomethingChanged,#what=self);        
      Send(poOwner,@MsgSendUser,#message_rsc=vrItem_broken,
           #parm1=Send(self,@GetName));
      Send(poOwner,@TryUnuseItem,#what=self);
      
      return;
   }

   AdjustsMaxHealth()
   {
      return FALSE;
   }

   AdjustsMaxMana()
   {
      return FALSE;
   }

   IsItemType(type = ITEMTYPE_MISC)
   {
      // Check for misc items (type 0)
      if type = viItem_type            
      {
         return TRUE;
      }               

      return (viItem_type & type);
   }

   DoShatter()
   "Shatters the item.  Include any special functions here."
   {
      Send(self,@Delete);

      return;
   }
   
   Delete()
   {
      Send(self,@ClearAllItemAttributes);
      
      propagate;
   }

   ObjectCorpseFading(corpse=$)
   {
      local lData;
          
      if NOT Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {
         return;
      }
          
      lData = Send(self,@GetAttributeData,#ItemAtt=IA_CORPSEPOINTER);

      if lData = $
      {
         return;
      }

      if Nth(lData,3) = corpse
      {
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }
      
      return;
   }

   GetPaletteTranslation()
   {
      return piItem_flags & ITEM_PALETTE_MASK;
   }

   SetPaletteTranslation(translation = $)
   {
      piItem_flags = (piItem_flags & ~ITEM_PALETTE_MASK) | translation;
      
      return;
   }

   SetItemColor(flags = $)
   {
	   piItem_flags = flags;

	   pbColored = TRUE;

	   return;
   }
   

   CanIdentify()
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanIdentify,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }
   
   CanShatter()
   "Called by the shatter spell.  If this is false, the spell fails."
   { 
      local i, oItemAtt, iNum;
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanShatter,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;  
   }

   CanSwap()
   "Called by the swap spell.  If this is false, the spell fails."
   {  
      local i, oItemAtt, iNum;
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!"); continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanSwap,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanWeaken()
   "Called by the Brittle spell, among other thing."
   {  
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");
            
            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanWeaken,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanMend()
   "Called by the Mend spell.  If this returns false, the spell fails."
   "Most things are not mendable."
   {  
      return FALSE; 
   }

   CanEnchant(oSpell = $)
   "Can a particular spell enchantment target this item.  Note that for "
   "artifice and shroud, this is true, but for curse and the three "
   "enchantments, this is false."
   {
      local i, oItemAtt, iSpell, iNum;

      iSpell = Send(oSpell,@GetSpellNum);
      if iSpell = SID_HOLY_WEAPON
         OR iSpell = SID_UNHOLY_WEAPON
         OR iSpell = SID_ENCHANT_WEAPON
         OR iSpell = SID_CURSE_WEAPON
      {
         return FALSE;
      }

      if iSpell = SID_SHROUD
      AND (IsClass(self,&Weapon)
         OR IsClass(self,&DefenseModifier))
      {
         foreach i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                            
            if oItemAtt = $
            {
               Debug("Illegal ItemAtt in list!");
               
               continue;
            }
            
            if NOT Send(oItemAtt,@ItemCanEnchant,#oItem=self)
            {
               return FALSE;
            }
         }

         return TRUE;
      }

      return FALSE;
   }

   OwnerKilled(what = $)
   "Called when our owner dies. Killer is passed as 'what' parameter."
   {
      local i, iNum, oItemAtt;

      // Check itematts.
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

         Send(oItemAtt,@OwnerKilled);
      }

      return;
   }

   DropOnDeath()
   "Most items are dropped on death.  But, assassin's blades and a few other "
   "things are not."
   {
      local i, oItemAtt, iNum;
      
      // Check ItemAtts to be sure nothing funky is there
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemDropOnDeath)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   CanBeGivenToNPC()
   "For most things this is TRUE.  However, objects like black daggers cannot "
   "be given to NPCs for any reason."
   {
      local i;
      
      foreach i in plItem_Attributes
      {
         // KLUDGE: We specifically prevent made items from being given to NPCs.
         //  Should be more general.
         if Send(self,@GetNumFromCompound,#compound=First(i)) = IA_MADE
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }   

   CanBeStoredInVault()
   "Black daggers and tokens, especially, cannot be stored in vaults."
   {
      return TRUE;
   }

   ReqDMDelete()
   "By default this item can be removed."
   {
      return NOT (piUsed = 1 OR pbIn_use OR pbColored);
   }
   
   // An item can format a text effect for players in the room to see,
   //  whether held by a player or not.  If range is specified,
   //  only players within that range will see the effect.
   // Also, one player can be specified (in except) to treat that player
   //  separately.
   RoomMessage(range = $, except = $, except_rsc = $, message_rsc = $,
               parm1 = $, parm2 = $, parm3 = $, parm4 = $,
               parm5 = $, parm6 = $, parm7 = $, parm8 = $)
   {
      local oRoom, oSource, i, range_squared, oPlayer;

      if range <> $
      {
         range_squared = range * range;
      }

      oSource = self;
      oRoom = poOwner;
      if oRoom = $
      {
         return FALSE;
      }
      
      if IsClass(oRoom,&Player)
      {
         oSource = poOwner;
         oRoom = Send(oRoom, @GetOwner);
      }
      
      if oRoom = $ OR NOT IsClass(oRoom,&Room)
      {
         return FALSE;
      }

      foreach i in Send(oRoom,@GetHolderActive)
      {
         oPlayer = Send(oRoom,@HolderExtractObject,#data=i);
         if NOT IsClass(oPlayer,&Player)
         {
            continue;
         }

         if range <> $
            AND Send(oPlayer,@SquaredDistanceTo,#what=oSource) >= range_squared
         {
            continue;
         }

         if oPlayer = except
         {
            if except_rsc = $
            {
               continue;
            }

            // message comes from except_rsc, with parm1 missing.
            Send(oPlayer,@MsgSendUser,#message_rsc=except_rsc,
                 #parm1=parm3,#parm2=parm4,#parm3=parm5,#parm4=parm6,
                 #parm5=parm7,#parm6=parm8);
         }
         else
         {
            Send(oPlayer,@MsgSendUser,#message_rsc=message_rsc,
                 #parm1=parm1,#parm2=parm2,#parm3=parm3,#parm4=parm4,
                 #parm5=parm5,#parm6=parm6,#parm7=parm7,#parm8=parm8);
         }
      }

      return;
   }

   //  Item Attributes, added 4 March 97 by Damion Schubert
   // 
   //  ItemAtts are any special attributes that an item might have.  
   //  Examples include training weapons, poisoned weapons and 
   //  enchanted weapons.  These have been generalized so the same 
   //  ItemAtt may be applied to any item.
   //
   //  The ItemAtt Struct (plItem_attributes) is as follows
   //
   //    plItem_attributes = \
   //       [ [WA_const_name, timer, primary_state, secondary_state],
   //         [WA_const_name2, timer, primary_state, secondary_state],
   //         etc.
   //       ]
   //
   //  WA_const_name : a unique constant name as found in blakston.khd
   //  timer : a timer, most often counting down to the enchantment's
   //    extinction.  However, since Item enchantments may last for days, 
   //    the timer may just count down hours, with an additional (usually 
   //    secondary) state value counting days.  If this timer doesn't exist,
   //    the ItemAtt is permanent.
   //  states : any value that the ItemAtt needs to know.  For example, the
   //    strength of attributes such as the strength of poison or the damage
   //    bonus might be stored. Individual ItemAtt code should be examined to
   //    see what this is.
   //
   //  Note, there are thousands of items in a live server.  As a
   //    result, I've taken actions to ensure that as few list nodes are used as
   //    possible for each ItemAtt, so rather than store blank fields which are 
   //    never used, I make it easy for the individual ItemAtts to decide to 
   //    store what information they deem necessary. 
   //    I check to see if those fields exist when using them, allowing me to
   //    collapse the ItemAtt struct as much as possible.  For example, a 
   //    training attribute struct only has one argument, the ItemAtt ID:
   //
   //    plItem_Attributes = [[WA_TRAINING]];
   //
   //  By comparison, you may have a fiery sword, which is only fiery
   //    for a short time (as determined by a timer).  That list looks
   //    like:
   //
   //    plItem_Attributes = [[WA_ATCKTYPE, DurationTimer, ATCK_FIRE]];
   //
   //  This 'telescoping' saves memory.

   //// Item Attribute Functions

   HasAttribute(ItemAtt = $)
   {
      local i;

      foreach i in plItem_attributes
      {
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   HasAnyAttribute()
   {
      return plItem_attributes <> $;
   }

   CanUserAddSpecialAttributes()
   "Special attributes would be enchantments more powerful than glow, shroud "
   "or the school-based holy/unholy/Kraanan enchants. To prevent the creation "
   "of super powerful weapons, disallow adding special attributes if the item "
   "already has a very powerful attribute on it."
   {
      local i, iNum, oItemAtt;

      foreach i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

         // Specific itematts can disallow the addition of another powerful
         // itematt. Things like blind, hold and purge attributes would do this.
         if (NOT Send(oItemAtt,@ItemCanAddSpecialAttributes))
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   GetAttributeData(ItemAtt = $, index = 1)
   {
      local i, n;

      n = 0;
      foreach i in plItem_attributes
      {
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt
         {
            n = n + 1;
            if n = index
            {
               return i;
            }
         }
      }

      return $;
   }

   GetNumFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      return compound / 100;
   }

   GetIDStatusFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      // If compound is odd, it is IDed. If even, it is not.

      if (compound % 2) = 1
      {
         return TRUE;
      }

      return FALSE;
   }

   RevealHiddenAttributes()
   {
      local i, bDone;

      bDone = FALSE;
      foreach i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            SetFirst(i,(First(i)+1));
            bDone = TRUE;
         }
      }

      return bDone;
   }

   AddAttributeSpecifics(litemAtt=$)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      if lItemAtt = $ 
      {
         Debug("lItemAtt = $!  Most likely, lItemAtt called directly instead "
               "of from itematt.kod");
      }

      plItem_attributes = Cons(lItemAtt,plItem_attributes);

      return;
   }

   RemoveItemAttIfPresent(iNum=0)
   "Attempts to removes a specific item attribute if present.  Used to "
   "remove an attribute from all items without generating debug messages "
   "if the item does not have that attribute."
   {
      local oItemAtt;

      if iNum = 0
      {
         return;
      }

      oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

      if oItemAtt = $
      {
         return;
      }

      if Send(self,@HasAttribute,#ItemAtt=iNum)
      {
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }

      return;
   }

   RemoveAttribute(ItemAtt=$)
   "All this does is calls the itematt.kod version of the same thing. "
   "This function is largely unnecessary, and is here only for convenience."
   {
      local oItemAtt;

      if ItemAtt = $
      {
         return;
      }

      oItemAtt = Send(SYS,@FindItemAttByNum,#num=ItemAtt);

      if oItemAtt = $
      {
         Debug("Illegal data sent to RemoveAttribute");

         return;
      }

      Send(oItemAtt,@RemoveFromItem,#oItem=self);

      return;
   }

   RemoveAttributeSpecifics(oItemAtt=$, ItemAtt = 0, index = 1)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      local lData;

      if oItemAtt = $ OR ItemAtt = 0
      {
         Debug("Illegal data sent to RemoveAttributeSpecific");

         return;
      }

      lData = Send(self,@GetAttributeData,#ItemAtt=ItemAtt,#index=index);
      if lData = $
      {
         Debug("Can't remove a node that isn't there!"); return;
      }

      // First kill the timer if it has one
      if Send(oItemAtt,@HasTimer,#lData=lData)
      {
         if Nth(lData,2) <> $
         {
            DeleteTimer(Nth(lData,2));
            SetNth(lData,2,$);
         }
      }
      // now free the nodes
      plItem_Attributes = DelListElem(plItem_Attributes,lData);

      return;
   }

   AttributeTimer(timer=$)
   {
      local i, oItemAtt, iNum;

      if timer = $
      {
         Debug("Timer = $!");

         return;
      }

      foreach i in plItem_Attributes
      {
         if Length(i) >= 2 AND Nth(i,2) = timer
         {  
            // This is the timer that just expired.
            SetNth(i,2,$); // clear it in the data structure first
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            Send(oItemAtt,@TimerExpired,#oItem=self,#lData=i);

            return;
         }
      }

      Debug("AttributeTimer didn't find enchantment to get rid of!");

      return;
   }

   ClearAllItemAttributes()
   "Most likely called if the Item is deleted."
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }

         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }

      // All items should have cleared fine.  If not, something went wrong.
      if plItem_Attributes <> $
      {
         Debug("Clearing all Item Attributes failed!");
         plItem_Attributes = $;
      }

      return;
   }

   BuildDescName()
   {
      local i, iHigh_index, oHigh_obj, oItemAtt, iPriority, iNum;

      if plItem_Attributes = $
      {
         propagate;
      }

      iHigh_index = 0;  oHigh_obj = $;
      foreach i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            // If not identified, keep on marching.
            continue;
         }

         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

         iPriority = Send(oItemAtt,@GetNamePriority);
         if iPriority > iHigh_index
         {
            iHigh_index = iPriority;
            oHigh_obj = oItemAtt;
         }
      }

      if oHigh_obj = $
      {
         propagate;
      }

      Send(oHigh_obj,@ItemBuildDescName,#oItem=self);

      return;
   }

   SetTimer(timer_duration=$)
   {
      local tTimer;
      
      if timer_duration = $
      {
         return $;
      }

      tTimer = CreateTimer(self,@AttributeTimer,timer_duration);

      return tTimer;
   }

   GetBaseSpellModifier(oSpell=$)
   {
      // Doing it this way, we can have different items give different bonuses
      //  in different situations, while still giving itematt bonuses.
      return viSpell_modifier;
   }

   GetSpellModifier(oSpell=$)
   {
      local oItemAtt, iModifier, i, iNum, oObjectAttribute;

      iModifier = Send(self,@GetBaseSpellModifier,#oSpell=oSpell);
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iModifier = iModifier + Send(oItemAtt,@ItemGetSpellModifier,
                                      #oSpell=oSpell,#oCaster=poOwner);
      }

      foreach oObjectAttribute in plObject_attributes
      {
         iModifier = Send(oObjectAttribute,@ModifySpellPower,
                           #iModifier=iModifier,#oSpell=oSpell,
                           #oCaster=poOwner);
      }

      return iModifier;
   }

   GetItemXPBonus()
   {
      local oItemAtt, iXP, i, iNum, oObjectAttribute;

      iXP = 0;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         if (iNum = IA_XP_KILL_BONUS)
         {
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            iXP = iXP + Send(oItemAtt,@GetXPBonusFromCompound,
                              #iCompound=First(i));
         }
      }

      return iXP;
   }

   GetHeatDamage()
   "Only things worn at the armor position will be asked this, but "
   "just in case, default is 0."
   {
      return 0;
   }

   GetShirtIcon(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrIcon_male;
      }

      return vrIcon_female;
   }

   GetLeftArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         foreach i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideLeftArm,#who=who);
            }
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLeftarm_male;
      }

      return vrLeftarm_female;
   }

   OverrideArmsForGauntlets()
   {
      return FALSE;
   }

   OverrideArms()
   {
      return FALSE;
   }

   GetOverrideRightArm()
   {
      return $;
   }

   GetOverrideLeftArm()
   {
      return $;
   }

   GetRightArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         foreach i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideRightArm,#who=who);
            }
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrRightarm_male;
      }

      return vrRightarm_female;
   }

   GetNakedLeftArm(who=$)
   {
      local i;

      foreach i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideLeftArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return nakedleftarm_male;
      }

      return nakedleftarm_female;
   }

   GetNakedRightArm(who=$)
   {
      local i;

      foreach i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideRightArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return NakedRightarm_male;
      }

      return NakedRightarm_female;
   }

   GetLegs(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLegs_male;
      }

      return vrLegs_female;
   }

   HasSkinTones()
   {
      return FALSE;
   }

   ShowShirt()
   {
      return FALSE;
   }

   ResetSkinColor()
   {
      local iSkin_color, iColor, iXlat;

      if NOT Send(self,@HasSkinTones)
      {
         return;
      }

      iSkin_Color = Send(SYS,@DecodeSecondaryColor,
                         #xlat=Send(self,@GetPaletteTranslation));
      if iSkin_Color <> Send(poOwner,@GetSkinColor)
      {
         iSkin_Color = Send(poOwner,@GetSkinColor);
         iSkin_color = Send(poOwner,@ConvertSkinColorToXLAT,
                            #skin_color=iSkin_color);
         iColor = Send(SYS,@DecodePrimaryColor,
                       #xlat=Send(self,@GetPaletteTranslation));

         iXlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iColor,
                      #Color2=iSkin_color);
         Send(self,@SetPaletteTranslation,#translation=iXlat);
      }

      return;
   }

   ResetXLATsToShirt()
   {
      local iSkin_color, iColor, iXlat, iShirt_XLAT;

      if NOT Send(self,@ShowShirt)
      {
         return;
      }
      iShirt_XLAT = Send(poOwner,@GetCurrentShirtColor);

      if (iShirt_XLAT <> Send(self,@GetPaletteTranslation))
      {
         Send(self,@SetPaletteTranslation,#translation=iShirt_Xlat);
      }

      return;
   }

   UndoPlayerArt()
   {
      local oRoom, oShirt;

      if (poOwner <> $)
      {
         if vrIcon_male <> $
         {
            Send(poOwner,@ResetPlayerIcon,#alldone=FALSE);
         }

         if vrLeftArm_male <> $
         {
            Send(poOwner,@ResetPlayerArms,#alldone=FALSE);
         }

         if vrLegs_male <> $
         {
            Send(poOwner,@ResetPlayerLegs,#alldone=FALSE);
         }

         Post(poOwner,@RefreshPlayerVisualGear);

         oRoom = Send(poOwner,@GetOwner);
         if oRoom <> $
         {
            Post(oRoom,@SomethingChanged,#what=poOwner);
         }
      }

      return;
   }

   DoPlayerArt()
   {
      local oRoom;

      // make the player's hands match his sleeves.
      Send(self,@ResetSkinColor);

      if Send(self,@ShowShirt)
      {
         Send(self,@ResetXLATsToShirt);
      }

      if vrLeftArm_male <> $
      {
         Send(self,@SetArms,#alldone=FALSE);
      }

      if vrIcon_male <> $
      {
         Send(self,@SetIcon,#alldone=FALSE);
      }

      if vrLegs_male <> $
      {
         Send(self,@SetLegs,#alldone=FALSE);
      }

      oRoom = Send(poOwner,@GetOwner);
      if oRoom <> $
      {
         Send(oRoom,@SomethingChanged,#what=poOwner);
      }

      return;
   }

   ItemChangesArms()
   {
      return vrLeftArm_male <> $;
   }

   SetNakedArms()
   {
      local iSkin_xlat;

      iSkin_Xlat = Send(poOwner,@GetSkinColor);
      iSkin_Xlat = Send(poOwner,@ConvertSkinColorToXLAT,
                        #skin_color=iSkin_Xlat);
      iSkin_Xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iSkin_XLAT,
                        #color2=iSkin_XLAT);
      Send(poOwner,@SetPlayerArms,#what=self,
            #new_left_arm=Send(self,@GetNakedLeftArm,#who=poOwner),
            #new_right_arm=Send(self,@GetNakedRightArm,#who=poOwner),
            #translation=iSkin_Xlat,#alldone=FALSE);

      return;
   }

   SetArms()
   {
      Send(poOwner,@SetPlayerArms,#what=self,
            #new_left_arm=Send(self,@GetLeftArm,#who=poOwner),
            #new_right_arm=Send(self,@GetRightArm,#who=poOwner),
            #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);

      return;
   }

   SetIcon()
   {
      Send(poOwner,@SetPlayerIcon,#what=self,
            #new_icon=Send(self,@GetShirtIcon,#who=poOwner),
            #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);

      return;
   }

   SetLegs()
   {
      Send(poOwner,@SetPlayerLegs,#what=self,
            #new_legs=Send(self,@GetLegs,#who=poOwner),
            #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);

      return;
   }

   IsPlural()
   {
      return FALSE;
   }

   GetUnrevealedColor()
   "Returns the item's color before being revealed."
   {
      return viUnrevealedColor;
   }

   GetRevealedColor()
   "Returns the item's mystery revealed color."
   {
      return viRevealedColor;
   }

   RevealHiddenColor()
   "Shows the item's true color."
   {
      if viRevealedColor <> 0
         AND viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = (viUnrevealedColor & ITEM_PALETTE_MASK)
      {
         Send(self,@SetPaletteTranslation,#translation=viRevealedColor);

         return TRUE;
      }

      return FALSE;
   }

   GetCurrentResistances()
   {
      local lCurrentResistances, oObj;

      lCurrentResistances = Send(self,@GetResistanceModifiers);

      foreach oObj in plObject_attributes
      {
         lCurrentResistances = Send(oObj,@ModifyResistance,
                                    #resistance_list=lCurrentResistances);
      }

      return lCurrentResistances;
   }

   ModifyResistance(resistance_list=$)
   {
      local i, lCurrentResistances;

      lCurrentResistances = Send(self,@GetCurrentResistances);

      foreach i in lCurrentResistances
      {
         resistance_list = Send(SYS,@AddResistance,#what=First(i),#value=Nth(i,2),
                                 #resistance_list=resistance_list);
      }

      return resistance_list;
   }

   IsInSameRoom(what = $)
   {
      if Send(self,@GetOwner) <> $
         AND IsClass(Send(self,@GetOwner),&Room)
         AND Send(what,@GetOwner) <> $
         AND IsClass(Send(what,@GetOwner),&Room)
         AND Send(self,@GetOwner) = Send(what,@GetOwner)
      {
         return TRUE;
      }

      return FALSE;
   }

   SquaredDistanceTo(what = $)
   "Computes squared distance to <what>. Returns $ for any object that is not within a room."
   {
      local iRow, iCol;

      if NOT Send(self,@IsInSameRoom,#what=what)
      {
         return $;
      }

      iRow = Send(what,@GetRow);
      iCol = Send(what,@GetCol);

      // Sanity checking
      if iRow = $ OR iCol = $ OR Send(self,@GetRow) = $ OR Send(self,@GetCol) = $
      {
         return $;
      }

      return Send(self,@SquaredDistanceToLocation,#row=iRow,#col=iCol);
   }

   SquaredDistanceToLocation(row = $, col = $)
   "Computes squared distance to (row,col)"
   {
      local iRow_diff, iCol_diff;

      iRow_diff = Send(self,@GetRow) - row;
      iCol_diff = Send(self,@GetCol) - col;

      return  (iRow_diff * iRow_diff + iCol_diff * iCol_diff);
   }

   AddMagicFlag()
   {
      if viObject_flags <> (OF_GETTABLE | OF_ITEM_MAGIC)
      {
         viObject_flags = viObject_flags | OF_ITEM_MAGIC;
      }

      if poOwner <> $
         AND IsClass(poOwner,&User)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveMagicFlag()
   {
      local i, iNum, oItemAtt;

      foreach i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         
         if Send(oItemAtt,@IsMagicalEffect)
         {
            viObject_flags = viObject_flags | OF_ITEM_MAGIC;

            if poOwner <> $
               AND IsClass(poOwner,&User)
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      viObject_flags = viObject_flags & ~OF_ITEM_MAGIC;

      if poOwner <> $
         AND IsClass(poOwner,&User)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ReportDMCreated()
   {
      local i, iNum;

      foreach i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         if (iNum = IA_DM_CREATED)
         {
            if (poOwner = $)
            {
               Debug("Found item ",self,Send(self,@GetTrueName)," created by ",
                     Send(Nth(i,3),@GetTrueName)," $ owner.");
            }
            else
            {
               Debug("Found item ",self,Send(self,@GetTrueName)," created by ",
                     Send(Nth(i,3),@GetTrueName)," owned by ",
                     Send(poOwner,@GetTrueName));
            }

            return;
         }
      }

      return;
   }

   RemoveDMCreated()
   {
      local i, iNum;

      foreach i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         if (iNum = IA_DM_CREATED)
         {
            GodLog("Removing DM created itematt from ",self,", ",
                  Send(self,@GetTrueName));
            Send(self,@RemoveItemAttIfPresent,#iNum=IA_DM_CREATED);

            return;
         }
      }

      return;
   }

   CanSweep()
   {
      return TRUE;
   }

   PrintWeight()
   {
      GodLog(Send(self,@GetTrueName)," weight: ",viWeight," bulk: ",viBulk);

      return;
   }

   InUse()
   {
	   return (piUsed = 1 OR pbIn_use);
   }
   
   IsColored()
   {
	   return pbColored;
   }

   GetMiningBonus()
   {
      return viMiningBonus;
   }

   GetLoggingBonus()
   {
      return viLoggingBonus;
   }

   GetGatheringBonus()
   {
      return viGatheringBonus;
   }

   GetSkinningBonus()
   {
      return viSkinningBonus;
   }
   
   SetDefense(number = $)
   {
      if number = $
      {
         return;
      }

      piDefense_bonus = piDefense_bonus + number;
      return piDefense_bonus;
   }

   SetOffense(number = $)
   {
      if number = $
      {
         return;
      }

      piHitBonus = piHitBonus + number;
      return piHitBonus;
   }

   GetRefinedVersion()
   {
      return viRefined;
   }
   
   GetRefinedAt()
   {
      return viRefinedAt;
   }

   GetRefineSpell()
   {
      return viRefineSpell;
   }
   
   SetIndestructible()
   {
      piIndestructible = TRUE;

      return;
   }

   IsIndestructible()
   {
      return piIndestructible;
   }

   SetCrafter(Crafter=$)
   {
      poCrafter = Crafter;

      return;
   }

   GetCrafter()
   {
      return poCrafter;
   }

   SetItemEnchantment(ItemSpell=$)
   {
      poSpell = ItemSpell;

      return;
   }

   GetItemEnchantment()
   {
      return poSpell;
   }

   RemoveDye()
   {
      piItem_flags = piOriginalColor;

      pbColored = FALSE;

      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
